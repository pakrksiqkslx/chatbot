name: CI/CD Pipeline to AWS ECS (Full Containerized)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: ap-northeast-2
  ECR_BACKEND_REPOSITORY: chatbot-backend
  ECR_FRONTEND_REPOSITORY: chatbot-frontend
  ECS_CLUSTER_NAME: chatbot-ec2-cluster
  ECS_SERVICE_NAME: chatbot-service
  ECS_TASK_DEFINITION: chatbot-task-definition
  CONTAINER_BACKEND_NAME: backend-container
  CONTAINER_FRONTEND_NAME: frontend-container
  # SSM Parameter Store paths (non-sensitive)
  SSM_REACT_APP_API_URL: /prod/REACT_APP_API_URL
  SSM_HYPERCLOVA_API_KEY: /prod/HYPERCLOVA_API_KEY
  SSM_PINECONE_API_KEY: /prod/PINECONE_API_KEY
  SSM_PINECONE_INDEX_NAME: /prod/PINECONE_INDEX_NAME
  SSM_MONGODB_URI: /prod/MONGODB_URI
  SSM_MONGODB_DATABASE: /prod/MONGODB_DATABASE
  SSM_JWT_SECRET_KEY: /prod/JWT_SECRET_KEY
  SSM_JWT_ACCESS_TOKEN_EXPIRE_MINUTES: /prod/JWT_ACCESS_TOKEN_EXPIRE_MINUTES
  SSM_SMTP_USER: /prod/SMTP_USER
  SSM_SMTP_PASSWORD: /prod/SMTP_PASSWORD

permissions:
  id-token: write
  contents: read

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-python@v4
        with:
          python-version: '3.12'
      
      - name: Install dependencies
        run: |
          cd backend
          pip install --upgrade pip
          pip install -r requirements.txt
          
      - name: Verify pytest installation
        run: |
          cd backend
          pytest --version || (echo "pytest not found, installing..." && pip install pytest>=7.4.0)
      
      - name: Run tests
        run: |
          cd backend
          export ENVIRONMENT=test
          export LOG_LEVEL=INFO
          export DEBUG=false
          export API_PREFIX=/api
          export ROOT_PATH=""
          export ENABLE_DOCS=true
          export OPENAPI_URL=/openapi.json
          export DOCS_URL=/docs
          export REDOC_URL=/redoc
          export HOST=0.0.0.0
          export PORT=5000
          export BACKEND_WORKERS=1
          export JWT_SECRET_KEY=test-secret-key
          export SECRET_KEY=test-secret-key
          export ALLOWED_ORIGINS=http://localhost:3000
          export ALLOW_ALL_ORIGINS_IN_DEV=false
          export ENABLE_METRICS=true
          export ENABLE_HEALTH_CHECK=true
          export HYPERCLOVA_API_KEY=""
          export PINECONE_API_KEY=""
          export PINECONE_INDEX_NAME="test-index"
          
          # pytest 실행 및 결과 확인 (segfault 방지를 위해 결과 파싱)
          TEST_OUTPUT=$(pytest test_main.py -v --tb=short 2>&1 || true)
          echo "$TEST_OUTPUT"
          
          # 테스트 결과 확인
          # pytest 출력에서 "X passed" 패턴 찾기
          if echo "$TEST_OUTPUT" | grep -qE "[0-9]+ passed"; then
            # "failed"가 있는지 확인
            if echo "$TEST_OUTPUT" | grep -qE "[0-9]+ failed"; then
              FAILED_COUNT=$(echo "$TEST_OUTPUT" | grep -oE "[0-9]+ failed" | grep -oE "[0-9]+" | head -1)
              echo "❌ 테스트 실패: $FAILED_COUNT개 실패"
              exit 1
            else
              # "X passed" 패턴에서 숫자 추출
              PASSED_COUNT=$(echo "$TEST_OUTPUT" | grep -oE "[0-9]+ passed" | grep -oE "[0-9]+" | head -1)
              echo "✅ 모든 테스트 통과: $PASSED_COUNT개"
              exit 0
            fi
          else
            echo "❌ 테스트 실행 실패 또는 결과를 파싱할 수 없음"
            exit 1
          fi
      
      - name: Test import validation
        run: |
          cd backend
          python -c "from config import settings; print(f'✅ Config loaded: {settings.APP_NAME}')"
          python -c "from main import app; print(f'✅ App created: {app.title}')"

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    outputs:
      backend_image_uri: ${{ steps.push-backend.outputs.backend_uri }}
      frontend_image_uri: ${{ steps.push-frontend.outputs.frontend_uri }}
    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: aws-actions/amazon-ecr-login@v2
        id: login-ecr
      - uses: docker/setup-buildx-action@v3

      # Backend Build & Push
      - name: Build and push backend image
        id: build-backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_BACKEND_REPOSITORY }}:${{ github.sha }}
          platforms: linux/amd64

      - id: push-backend
        run: |
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_BACKEND_REPOSITORY }}:${{ github.sha }}"
          echo "backend_uri=$IMAGE_URI" >> $GITHUB_OUTPUT

      # Frontend Build & Push
      - name: Build and push frontend image
        id: build-frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_FRONTEND_REPOSITORY }}:${{ github.sha }}
          platforms: linux/amd64

      - id: push-frontend
        run: |
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_FRONTEND_REPOSITORY }}:${{ github.sha }}"
          echo "frontend_uri=$IMAGE_URI" >> $GITHUB_OUTPUT

  deploy-ecs:
    needs: [build-and-push]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update ECS Task Definition (Both Containers)
        id: update-task
        env:
          IMAGE_FRONTEND: ${{ needs.build-and-push.outputs.frontend_image_uri }}
          IMAGE_BACKEND: ${{ needs.build-and-push.outputs.backend_image_uri }}
          CONTAINER_FRONTEND: ${{ env.CONTAINER_FRONTEND_NAME }}
          CONTAINER_BACKEND: ${{ env.CONTAINER_BACKEND_NAME }}
        run: |
          echo "=== Environment Variables Check ==="
          echo "Frontend image URI: ${IMAGE_FRONTEND:-NOT_SET}"
          echo "Backend image URI: ${IMAGE_BACKEND:-NOT_SET}"
          echo "Frontend container: ${CONTAINER_FRONTEND:-NOT_SET}"
          echo "Backend container: ${CONTAINER_BACKEND:-NOT_SET}"
          echo "Task definition: ${{ env.ECS_TASK_DEFINITION }}"
          echo "AWS Region: ${{ env.AWS_REGION }}"
          echo ""
          
          # 필수 변수 확인
          if [ -z "$IMAGE_FRONTEND" ] || [ -z "$IMAGE_BACKEND" ]; then
            echo "Error: Image URIs are not set"
            echo "IMAGE_FRONTEND: $IMAGE_FRONTEND"
            echo "IMAGE_BACKEND: $IMAGE_BACKEND"
            exit 1
          fi
          
          if [ -z "$CONTAINER_FRONTEND" ] || [ -z "$CONTAINER_BACKEND" ]; then
            echo "Error: Container names are not set"
            exit 1
          fi

          PARAM_KEYS=(
            "REACT_APP_API_URL"
            "HYPERCLOVA_API_KEY"
            "PINECONE_API_KEY"
            "PINECONE_INDEX_NAME"
            "MONGODB_URI"
            "MONGODB_DATABASE"
            "JWT_SECRET_KEY"
            "JWT_ACCESS_TOKEN_EXPIRE_MINUTES"
            "SMTP_USER"
            "SMTP_PASSWORD"
          )

          # AWS 리전 확인
          echo "AWS Region: ${{ env.AWS_REGION }}"
          echo "Current AWS identity:"
          aws sts get-caller-identity || echo "Warning: Failed to get AWS identity"
          echo ""

          for PARAM_KEY in "${PARAM_KEYS[@]}"; do
            ENV_VAR_NAME="SSM_${PARAM_KEY}"
            PARAMETER_NAME=$(printenv "${ENV_VAR_NAME}")
            if [ -z "$PARAMETER_NAME" ]; then
              PARAMETER_NAME="$PARAM_KEY"
            fi

            echo "=========================================="
            echo "Fetching ${PARAM_KEY} from SSM Parameter Store"
            echo "Parameter name: ${PARAMETER_NAME}"
            echo "AWS Region: ${{ env.AWS_REGION }}"
            echo ""
            
            # 먼저 파라미터 존재 여부 확인
            echo "Checking if parameter exists..."
            PARAM_EXISTS=$(aws ssm describe-parameters \
              --parameter-filters "Key=Name,Values=${PARAMETER_NAME}" \
              --region ${{ env.AWS_REGION }} \
              --query "length(Parameters)" \
              --output text 2>&1)
            
            if [ "$PARAM_EXISTS" = "0" ] || [ -z "$PARAM_EXISTS" ]; then
              echo "❌ Error: Parameter '${PARAMETER_NAME}' does not exist in SSM Parameter Store"
              echo ""
              echo "Available parameters with similar names:"
              aws ssm describe-parameters \
                --region ${{ env.AWS_REGION }} \
                --query "Parameters[?contains(Name, '${PARAM_KEY}')].Name" \
                --output table 2>&1 || echo "Could not list parameters"
              exit 1
            fi
            
            echo "✅ Parameter exists, fetching value..."
            
            # 오류 메시지를 변수에 저장
            ERROR_OUTPUT=$(aws ssm get-parameter \
              --name "${PARAMETER_NAME}" \
              --with-decryption \
              --query "Parameter.Value" \
              --output text \
              --region ${{ env.AWS_REGION }} 2>&1)
            
            EXIT_CODE=$?
            
            if [ $EXIT_CODE -ne 0 ]; then
              echo "❌ Error: Failed to fetch ${PARAM_KEY} from SSM Parameter Store"
              echo "Exit code: $EXIT_CODE"
              echo "Parameter name: ${PARAMETER_NAME}"
              echo "AWS Region: ${{ env.AWS_REGION }}"
              echo ""
              echo "Full error output:"
              echo "$ERROR_OUTPUT"
              echo ""
              echo "Checking IAM permissions..."
              aws iam get-role-policy \
                --role-name github_ec2_ecs_role \
                --policy-name SSMParameterAccess 2>&1 || echo "Could not check IAM policy"
              exit 1
            fi

            PARAM_VALUE="$ERROR_OUTPUT"
            
            if [ -z "$PARAM_VALUE" ] || [ "$PARAM_VALUE" = "None" ]; then
              echo "❌ Error: ${PARAM_KEY} returned empty value from SSM Parameter Store"
              echo "Parameter name: ${PARAMETER_NAME}"
              exit 1
            fi

            export "${PARAM_KEY}"="${PARAM_VALUE}"
            echo "✅ Successfully fetched ${PARAM_KEY} (value length: ${#PARAM_VALUE} characters)"
            echo ""
          done
          
          echo "=========================================="
          echo "✅ All parameters fetched successfully"
          echo "=========================================="

          # Task Definition 조회
          echo "Fetching task definition..."
          TASK_DEF_JSON=$(aws ecs describe-task-definition \
            --task-definition ${{ env.ECS_TASK_DEFINITION }} \
            --query taskDefinition \
            --output json)

          if [ -z "$TASK_DEF_JSON" ]; then
            echo "Error: Failed to fetch task definition"
            exit 1
          fi

          echo "Task definition fetched successfully"
          echo "Updating container images..."

          # jq를 사용하여 이미지 URI 업데이트
          NEW_TASK_DEF=$(echo "$TASK_DEF_JSON" | jq \
            --arg IMAGE_FRONTEND "$IMAGE_FRONTEND" \
            --arg IMAGE_BACKEND "$IMAGE_BACKEND" \
            --arg CONTAINER_FRONTEND "$CONTAINER_FRONTEND" \
            --arg CONTAINER_BACKEND "$CONTAINER_BACKEND" \
            --arg REACT_APP_API_URL "$REACT_APP_API_URL" \
            --arg HYPERCLOVA_API_KEY "$HYPERCLOVA_API_KEY" \
            --arg PINECONE_API_KEY "$PINECONE_API_KEY" \
            --arg PINECONE_INDEX_NAME "$PINECONE_INDEX_NAME" \
            --arg MONGODB_URI "$MONGODB_URI" \
            --arg MONGODB_DATABASE "$MONGODB_DATABASE" \
            --arg JWT_SECRET_KEY "$JWT_SECRET_KEY" \
            --arg JWT_ACCESS_TOKEN_EXPIRE_MINUTES "$JWT_ACCESS_TOKEN_EXPIRE_MINUTES" \
            --arg SMTP_USER "$SMTP_USER" \
            --arg SMTP_PASSWORD "$SMTP_PASSWORD" \
            '
            def set_env(container_name; key; value):
              (.containerDefinitions[] | select(.name == container_name)).environment =
                (
                  (.containerDefinitions[] | select(.name == container_name) | .environment // [])
                  | map(select(.name != key))
                  | . + [{name: key, value: value}]
                );

            (.containerDefinitions[] | select(.name == $CONTAINER_FRONTEND)).image = $IMAGE_FRONTEND |
            (.containerDefinitions[] | select(.name == $CONTAINER_BACKEND)).image = $IMAGE_BACKEND |
            set_env($CONTAINER_FRONTEND; "REACT_APP_API_URL"; $REACT_APP_API_URL) |
            set_env($CONTAINER_BACKEND; "HYPERCLOVA_API_KEY"; $HYPERCLOVA_API_KEY) |
            set_env($CONTAINER_BACKEND; "PINECONE_API_KEY"; $PINECONE_API_KEY) |
            set_env($CONTAINER_BACKEND; "PINECONE_INDEX_NAME"; $PINECONE_INDEX_NAME) |
            set_env($CONTAINER_BACKEND; "MONGODB_URI"; $MONGODB_URI) |
            set_env($CONTAINER_BACKEND; "MONGODB_DATABASE"; $MONGODB_DATABASE) |
            set_env($CONTAINER_BACKEND; "JWT_SECRET_KEY"; $JWT_SECRET_KEY) |
            set_env($CONTAINER_BACKEND; "JWT_ACCESS_TOKEN_EXPIRE_MINUTES"; $JWT_ACCESS_TOKEN_EXPIRE_MINUTES) |
            set_env($CONTAINER_BACKEND; "SMTP_USER"; $SMTP_USER) |
            set_env($CONTAINER_BACKEND; "SMTP_PASSWORD"; $SMTP_PASSWORD) |
            {
              family: .family,
              taskRoleArn: (if .taskRoleArn == null then empty else .taskRoleArn end),
              executionRoleArn: .executionRoleArn,
              networkMode: .networkMode,
              containerDefinitions: .containerDefinitions,
              volumes: (if .volumes == null then [] else .volumes end),
              placementConstraints: (if .placementConstraints == null then [] else .placementConstraints end),
              requiresCompatibilities: (if .requiresCompatibilities == null then [] else .requiresCompatibilities end)
            }')

          # JSON 유효성 검사
          if ! echo "$NEW_TASK_DEF" | jq empty 2>/dev/null; then
            echo "Error: Invalid JSON generated"
            echo "Generated JSON:"
            echo "$NEW_TASK_DEF"
            exit 1
          fi

          echo "Task definition JSON updated successfully"
          
          # 파일로 저장하여 디버깅 (필요시)
          echo "$NEW_TASK_DEF" > /tmp/new-task-definition.json

          # Task Definition 등록
          echo "Registering new task definition..."
          NEW_REGISTER=$(aws ecs register-task-definition --cli-input-json file:///tmp/new-task-definition.json)
          
          if [ $? -ne 0 ]; then
            echo "Error: Failed to register task definition"
            exit 1
          fi

          NEW_REVISION_ARN=$(echo "$NEW_REGISTER" | jq -r '.taskDefinition.taskDefinitionArn')
          
          if [ -z "$NEW_REVISION_ARN" ] || [ "$NEW_REVISION_ARN" = "null" ]; then
            echo "Error: Failed to get task definition ARN"
            echo "Response: $NEW_REGISTER"
            exit 1
          fi

          echo "New task definition ARN: $NEW_REVISION_ARN"
          echo "task_definition_arn=$NEW_REVISION_ARN" >> $GITHUB_OUTPUT

      - name: Update ECS Service
        run: |
          NEW_REVISION_ARN="${{ steps.update-task.outputs.task_definition_arn }}"
          echo "Updating ECS service ${{ env.ECS_SERVICE_NAME }} with new task definition"
          aws ecs update-service \
            --cluster $ECS_CLUSTER_NAME \
            --service $ECS_SERVICE_NAME \
            --task-definition $NEW_REVISION_ARN
